# Проектная работа "Веб-ларек"

Используемый стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами
- src/vendor/index.ts — файл с описанием бизнес-логики (PRESENTER)

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```
## Описание проекта "Веб-ларек"
"Веб-ларек" - интернет-магазин. По сути есть главная страница с перечнем товаров и значком корзины и множество модальных окон, которые обеспечивают возможность посмотреть конкретный товар и возможность оформить по нему заказ.
Макет: https://www.figma.com/design/50YEgxY8IYDYj7UQu7yChb/Веб-ларёк?node-id=1-735&t=5o12C686f6mogjbA-0

## Архитектурный паттерн
В качестве паттерна для построения архитектуры приложения (интернет-магазина) выбран MVP (Model-View-Presenter) - паттерн.
MVP разделяет приложение на три основных компонента:
- Модель (Model) — представляет бизнес-логику приложения и данные.
- Представление (View) — отображает данные пользователю и обрабатывает пользовательский ввод.
- Презентер (Presenter) — является посредником между моделью и представлением. Модель и представление взаимодействуют только через презентер.

## Более детальное описание
На главной странице загружаются доступные товары.
На главной странице отображается корзина с указанием количества товаров в ней.
Пользователь может кликнуть по корзине, откроется корзина с данными (название, цена) по товарам, которые в ней находятся.
Пользователь кликом открывает карточку товара для просмотра. Карточка товара содержит идентификатор товара, название товара, описание товара, изображение товара, категорию товара и цену.
Товар можно добавить только один раз, т.е. в процессе попытки добавления товара в корзину необходимо учитывать его возможное наличие в корзине.
После добавления всех товаров в корзину сумма по всем товарам суммируется. Также в корзине имеется возможность удалить любой товар.
ОФОРМЛЕНИЕ ЗАКАЗА ТОВАРА
ВСЕ, что используется при офорлении заказа (включая все, что должно быть заполнено в формах):
- Перечень карточек товара (массив).
- Общая сумма.
- Тип оплаты.
- Адрес доставки.
- Телефон.
- Email.
Далее должны производиться проверка заполненных полей и выбранного способа оплаты; очистка всех полей и выставление базового способа оплаты, очистка корзины.
После этого происходит завершение оформления заказа. В окне успеха завершения заказа отображается сумма по заказу.
API используется для:
- получения с сервера данныех для КАРТОЧКИ ТОВАРА, списка карточек,
- отправления данных по заказу (объект заказа).

## Данные и типы данных, используемые в приложении
КАРТОЧКА ТОВАРА
Тип, который описывает все категории товаров, представленные в макете интернет-магазина
```js
type TCardCategoryType = "софт-скил" | "кнопка" | "другое" | "хард-скил" | "дополнительное";
```
Данные по карточке
```js
interface ICard {
    id: string; //идентификатор товара
    title: string; //название товара
    description: string; //описание товара
    image: string; //изображение товара
    category: TCardCategoryType; //категория товара
    price: number | null; //цена товара
    index?: number; //??
}
```
Массив карточек
```js
interface ICardList {
    items: ICard[];
}
```
Данные карточки, используемые на главной странице
```js
type TCardMainPage = Pick<ICard, '_id' | 'title' | 'image' | 'price' | 'category'>;
```
Данные карточки, используемые в корзине
```js
type TCardBasket = Pick<ICard, '_id' | 'title' | 'price'>;
```
Данные карточки для отправки на сервер при заказе
```js
type TCardBasketOrder = Pick<ICard, '_id'>;
```
Данные карточки, используемые в модальном окне карты: интерфейс ICard

ЗАКАЗ
```js
interface IOrderForms {
    payment: string; //способ оплаты
    address: string; // адрес доставки 
    email: string; //email
    phone: string; //телефон
}

type FormErrors = Partial<Record<keyof IOrderForms, string>>;
```
Данные заказа, используемые в 1 модальном окне
```js
interface IOrderFormsFirst {
    payment: string;
	address: string;
}
```

Данные заказа, используемые в 2 модальном окне
```js
interface IOrderFormsSecond {
    email: string;
    phone: string;
}
```
```js
interface IOderFormsData {
    formErrors: FormErrors;
    setOrderFieldFirst(): void;
    setOrderFieldSecond(): void;
    validateOrderFirst(): void;
    validateOrderSecond(): void;
    clearorderfirst(): void;
    clearordersecond(): void;
}
```
Типизируем Коллекции

Коллекция Главная страницва. Перечень карточек на главной странице с учетом отображения карточки в отдельном окне
Модель для хранения данных карточек
```js
interface ICardsData {
    items: ICard[];
    preveiw: string | null; // идентификатор карточки при открытии в отдельном окне
    getCard(): ICard; //получить карточку по id
    getCardList(): ICard[]; //получить массив карточек
}
```
Коллекция Корзина
```js
interface ICardBasketData {
    items: TCardBasket[]; //перечень карточек в корзине ?? может, ICard
    getCardListInBasket(): TCardBasket[]; //получить массив карточек, а именно id всех карточек
    getCardListInBasketNumber(): number;  //чтобы число карточек получить для отображения на корзине
    addToBasket(): void; //добавить карточку в корзину
    removeFromBasket(): void; //удалить карточку из массива
    getTotalPrice(): number; // получить полную сумму заказа
    inBasket(): void; //проверить наличие карточки
    clearBasketData(): void; //очистить данные корзины после заказа
}

interface IOrderResult {
    id: string;
    total: number;
}
```

## Базовый код
### Класс Api
Содержит в себе базовую логику отправки запросов.
Методы:
- GET: выполняет get запрос на переданный эндпоинт и возвращает промис с объектом, которым ответил сервер.
- POST: принимает объект с данными, которые будут переданы в json в теле запроса и отправляет эти данные на эндпоинт, переданный как параметр при вызове метода. По умолчанию выполняется POST запрос, но метод запроса может быть переопределен заданием третьего параметра при вызове.

### Класс EventEmitter
Брокер событий позволяет отправлять события и подписываться на события, происходящие в системе (код класса написан, просто используем). Класс используется в PRESENTER и слоях приложения для запуска событий.
Основные методы, реализуемые классом описаны интерфейсом 'IEvents':
- on: подписка на событие,
- emit: инициализация события,
- trigger: возвращает функцию, при вызове которой инициализируется требуемое в параметрах событие.

### Класс Model
В параметры конструктора класса передается интерфейс IEvents. Базовая модель, чтобы можно было отличить ее от простых объектов с данными (класс описан в учебном проекте Оно, просто используем).

### Класс Component
Базовый класс для использования в классах представления VIEW (класс описан в учебном проекте Оно, просто используем).

## MODEL, PRESENTER, VIEW
### MODEL
#### Класс для работы с карточкой
Хранит массив карточек и хранит ту карточку, которую выбрали для просмотра.
Действия с данными.
Нужны методы для того, чтобы:
- получить массив карточек,
- получить 1 карточку с определенным id.
Работу с данными, связанными с добавлением, удалением из корзины, относим в класс Корзины, см. ниже.

Сам класс CardsData (отвечает за хранение и логику работы с данными карточек, скоррее всего будет наследовать базовый класс Model, см. ## Базовый код):
```js
protected  _items;
protected  _preview;
//events из Model

getCard(): ICard; //получить карточку по id, возвращаем данные карточки
getCardList(): ICard[]; //получить массив карточек
//СЕТТЕРЫ И ГЕТТЕРЫ
```
В классе, который реализует interface ICardsData, нужно создать также сеттеры и геттеры для получения и сохранения данных из полей класса:
- сохранения массива картчек и для получения массива карточек, 
- сохранения id и получения id (preview).


#### Класс для работы с заказом
Действия пользователя при работе с формами: Выбрать способ оплаты. Ввести адрес. Ввести телефон. Ввести e-mail. Подтвердить заказ.
Действия с данными. 
Нужны методы для того, чтобы:
- валидировать данные форм,
- очистить данные форм,

Сам класс OrderForms (отвечает за заказ, скоррее всего будет наследовать базовый класс Model, см. ## Базовый код) (использовала вариант реализации из учебного проекта Оно тебе надо для валидации):

```js
formErrors: FormErrors = {};
orderfirst: IOrderFormsFirst = {
        payment: '',
        address: ''
    }
    ordersecond: IOrderFormsSecond = {
        email: '',
        phone: ''
    };
    //events из Model
    setOrderFieldFirst(field: keyof IOrderFormsFirst, value: string): void;
    validateOrderFirst(): void;
    setOrderFieldSecond(field: keyof IOrderFormsSecond, value: string):void;
    validateOrderSecond(): void;
    clearorderfirst(): void;
    clearordersecond(): void;
```

### Класс Корзина
Работа с данными, которые относятся к корзине, добавлению, удалению товара в корзину.
Нужны методы для того, чтобы:
- получить массив карточек в корзине (id и число карточек),
- удалить или добавить карточку из корзины,
- получить полную сумму,
- очистить данные корзины после заказа.

Сам класс BasketData (отвечает за корзину, скоррее всего будет наследовать базовый класс Model, см. ## Базовый код):
```js
protected _items: TCardBasket[]; //перечень карточек в корзине ?? может, ICard
//events из Model

getCardListInBasket(): TCardBasket[]; //получить массив карточек, а именно id всех карточек)
getCardListInBasketNumber(): number;  //чтобы число карточек получить для отображения на корзине
addToBasket(): void; //добавить карточку в корзину
removeFromBasket(): void; //удалить карточку из массива
getTotalPrice(): number; // получить полную сумму заказа
inBasket(): void; //проверить наличие карточки
clearBasketData(): void; //очистить данные корзины после заказа
//СЕТТЕРЫ И ГЕТТЕРЫ
```
В классе, который реализует interface ICardBasketData, нужно создать сеттеры и геттеры для:
- сохранения массива картчоек и для получения массива карточек.

### VIEW
Компоненты:
- Класс Modal - Модальное окно: открывается при клике, закрывается при нажатии на крестик, пустое поле (для данного класса использован код из учебного прое Оно тебе надо)
Реализует интерфейс:
```js
interface IModalData {
    content: HTMLElement;
}
```
методы: open, close, render

- Класс Form (базовый класс для формы, будет наследоваться в конкретных формах) - Форма: может  отображать ошибки, кнопка должна уметь отключаться или включаться в зависимости от проверки валидности, закрывается при нажатии на кнопку (для данного класса использован код из учебного прое Оно тебе надо).
Реализует интерфейс:
```js
interface IFormState {
    valid: boolean;
    errors: string[];
}
```  
И классы: OrderFormContactsView, OrderFormPaymentDeliveryView - формы для отображения кнопок способа оплаты, адреса, телефона, email (в классах частично использован код учебного проекта Оно тебе надо).

- Классы CardViewBase, CardViewBasket, CardViewCardList, CardViewPreview -
Карточка: реализуется 4 класса для использования в зависимости от отображения. Кнопка выбранной карточки должна меняться в зависимости от того, находится ли товар в корзине, для товара с нулевой ценой быть неактивной.
Базовый класс CardViewBase минимально возможный набор полей: title, price. Для остальных классов идет расширение количества полей, установка сеттеров. Для класса CardViewPreview также прописывается метод disableButton() - дезактивировать кнопку.

- Класс BasketView - Корзина: отображает товары, добавленные в корзину (у товаров есть порядковые номера), общую сумму по заказу, имеет кнопку, при нажатии на которую происходит переход в первое модальное окно заказа. имеет метод для установки индекса товаров getnewindexlist().

- Класс SuccessOrder - Окно Подтверждение заказа: отображает общую сумму заказа, имеет кнопку, при нажатии на которую окно закрывается.   
Реализует интерфейс:

```js
interface ISuccess {
    content: number;
}
```
- Класс MainPage - Главная страница, отображается все карточки товаров и счетчик количества добавленных в корзину на корзине.   
Реализует интерфейс:
```js
interface IMainPage {
    counter: number;
    catalog: HTMLElement[];
    locked: boolean;
}
```
В интерфейсах (типах) привязка к элементам HTML.

### PRESENTER
В PRESENTER соединяем MODEL и VIEW воедино. Обеспечиваем взаимодействие с API.  
  
Бизнес-логика:  
  
Открываем страницу.  
Запускаем событие. Отображаем перечень карточек (в компоненте Главная страница), данные берем из Model - класс CardsData.  
  
  
Открываем карточку. По клику. Событие: 'card: selected'  
Запускаем событие. Отображаем данные карточки (передаем в соответствующий компонент Карточка). Также запускаем событие проверки наличия в корзине класс BasketData ??. Если в корзине есть - отображаем (передаем в компонент Карточка) Убрать, если нет - Купить. Отображаем количество товаров в корзине, данные берем из Model класс BasketData, метод getCardListInBasketNumber(). Учитываем то, что если цена нулевая, то кнопка неактивна.
  
Нажимаем В корзину  (если на кнопке текст Купить). 
 Добавляем карточку в Model  класс BasketData, метод addToBasket(). Отображаем в компоненте Карточка - меняем надпись на кнопке на Убрать.
  
Нажимаем Убрать (если на кнопке текст Убрать) .
Убираем карточку класс BasketData, метод removeFromBasket(), Отображаем в компоненте Карточка - меняем надпись на кнопке на Купить.  

Открываем корзину.  Событие: 'basket: open'
Запускаем событие. Отображаем данные корзины (передаем в компонент Корзина), данные получаем из Model класса BasketData items. Отображаем общую сумму, данные берем из класса BasketData getTotalPrice().
  
Нажимаем в Корзине на Удалить карточку. Событие: 'basket: removecard'   
Запускаем событие. Убираем карточку класс BasketData, метод removeFromBasket(). Отображаем в компоненте Корзина новый перечень. 
  
Нажимаем в Корзине на Оформить. Подтверждаем данные корзины. Событие: 'basket: submit'.
Запускаем событие  - открыть первую форму, запускаем проверку на валидность, передаем данные, отображаем ошибки при необходимости. Кнопка Далее неактивна, запускаем событие - передаем данные. Если валидация пройдена в отображении меняем кнопку на активную в компоненте Форма.
  
Нажимаем в первой форме на Далее. Подтверждаем данные первой формы. Событие: 'form-payment-delivery: submit'  
Запускае событие - открыть вторую форму, запускаем метод - получить полную сумму и перечень в корзине, запускаем проверку на валидность, передаем данные, отображаем ошибки при необходимости. Кнопка неактивна, запускаем событие - передаем данные. Если валидация пройдена в отображении меняем кнопку на активную в компоненте Форма.
  
Нажимаем Оплатить на второй форме.  Подтверждаем данные второй формы. Событие: 'contacts: submit'  
Запускаем событие. Создаем новый заказ. Данные по заказу берем из OderForms и BasketData... Передаем данные по заказу на сервер.  Открывам окно успеха. Отображаем полную сумму. Обнуляем данные форм и корзины (методы clearBasketData() и clearorderfirs(), clearordersecond()).

Нажимаем За новыми покупками. Событие: 'success:close'  

При открытии  модального окна блокируем прокрутку. При закрытии - снимаем блокировку.

### События
События, которые могут генерироваться в системе:
'cards: changed' - изменение массива карточек
'card: selected' - изменение открываемой в модальном окне карточки
  
События, возникающие при взаимодействии пользлователя с интерфейсом:
'basket: open' - открытие корзины   
'basket: removecard'  
'basket: submit' - подтверждение данных корзины    
'formErrorsFirst:change' - изменилось состояние валидации 1 формы  
'form-payment-delivery: open' - открытие 1 формы  
'order:submit' - подтверждение первой формы  
'formErrorsSecond:change' - изменилось состояние валидации 2 формы  
'form-contacts: open' - открытие 2 формы  
'contacts:submit' - подтверждение и отправка на сервер заказа  
'success:close' - закрытие окна успеха  
'modal: open' - событие открытия моального окна
'modal: close' - событие закрытия модального окна

## Класс взаимодействия с API
Класс, описывающий взаимодействие с API. Используются методы GET и POST.