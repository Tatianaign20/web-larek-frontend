# Проектная работа "Веб-ларек"

Используемый стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/styles/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```
## Описание проекта "Веб-ларек"
"Веб-ларек" - интернет-магазин. По сути есть главная страница с перечнем товаров и значком корзины и множество модальных окон, которые обеспечивают возможность посмотреть конкретный товар и возможность оформить по нему заказ.
Макет: https://www.figma.com/design/50YEgxY8IYDYj7UQu7yChb/Веб-ларёк?node-id=1-735&t=5o12C686f6mogjbA-0

## Архитектурный паттерн
В качестве паттерна для построения архитектуры приложения (интернет-магазина) выбран MVP (Model-View-Presenter) - паттерн.
MVP разделяет приложение на три основных компонента:
- Модель (Model) — представляет бизнес-логику приложения и данные.
- Представление (View) — отображает данные пользователю и обрабатывает пользовательский ввод.
- Презентер (Presenter) — является посредником между моделью и представлением. Модель и представление взаимодействуют только через презентер.

## Более детальное описание
На главной странице загружаются доступные товары.
На главной странице отображается корзина с указанием количества товаров в ней.
Пользователь может кликнуть по корзине, откроется корзина с данными (название, цена) по товарам, которые в ней находятся.
Пользователь кликом открывает карточку товара для просмотра. Карточка товара содержит идентификатор товара, название товара, описание товара, изображение товара, категорию товара и цену.
Товар можно добавить только один раз, т.е. в процессе попытки добавления товара в корзину необходимо учитывать его возможное наличие в корзине.
После добавления всех товаров в корзину сумма по всем товарам суммируется. Также в корзине имеется возможность удалить любой товар.
ОФОРМЛЕНИЕ ЗАКАЗА ТОВАРА
ВСЕ, что используется при офорлении заказа (включая все, что должно быть заполнено в формах):
- Перечень карточек товара (массив).
- Общая сумма.
- Тип оплаты.
- Адрес доставки.
- Телефон.
- Email.
Далее должны производиться проверка заполненных полей и выбранного способа оплаты (общая и каждая в отдельности); очистка всех полей и выставление базового способа оплаты.
После этого происходит завершение оформления заказа. В окне успеха завершения заказа отображается сумма по заказу.
API используется для:
- получения с сервера данныех для КАРТОЧКИ ТОВАРА, списка карточек,
- отправления данных по заказу (объект заказа).

## MODEL, PRESENTER, VIEW
### MODEL
Содержит следующие глобальные сущности: КАРТОЧКА ТОВАРА, ЗАКАЗ, описание приложения (AppState)  
КАРТОЧКА ТОВАРА  
Тип, который описывает все категории товаров, представленные в макете интернет-магазина:  
type CardCategoryType = "софт-скил" | "кнопка" | "другое" | "хард-скил" | "дополнительное";  

Данные по карточке товара, которые мы базово получаем с сервера:  
interface IСardApi {  
    id: string; //идентификатор товара  
    description: string; //описание товара  
    image: string; //изображение товара  
    title: string; //название товара  
    category: CardCategoryType; //категория товара  
    price: number | null; //цена товара  
}  
  
Данные, связанные с корзиной:  
interface ICardBasket {  
    selected: boolean; //значение выбора  
    addToBasket(): void; //метод добавления в корзину  
    removeFromBasket(): void; //метод удаления из корзины  
    }  
  
Тогда в целом описание КАРТОЧКИ ТОВАРА должно выглядеть следующим образом:  
interface ICard extends IСardApi, ICardBasket {}  
  
Тип, который описывает все возможные варианты оплаты товаров:  
type PaymentType = "Онлайн" | "При получении";  
  
Заполняем две формы:  
interface IOrderDeliveryPaymentForm {  
	payment: PaymentType; //способ оплаты  
	address: string; // адрес доставки  
}  
  
interface IOrderContactsForm {  
    email: string; //email пользователя  
    phone: string; //телефон пользователя  
}  
  
Полная форма (включает 2 формы):  
interface IOrderCommonForm extends IOrderDeliveryPaymentForm, IOrderContactsForm {}  
  
Тогда итоговый интерфейс оформления заказа выглядит примерно так:  
interface IOderForm extends IOrderCommonForm {  
    basket: ICard[]; //перечень карточек в корзине (в postman значение items)  
    validateOderForm(): boolean; //функция проверки корректности введенных пользователем данных  
    validateEmail(): boolean; //функция проверки корректности введенных пользователем данных - email  
    validatePhone(): boolean; //функция проверки корректности введенных пользователем данных - номера телефона  
    validatePayment(): boolean; //функция проверки корректности выбора способа оплаты - онлайн или при получении  
    validateAdress(): boolean;//функция проверки корректности введенных пользователем данных - адрес  
    clearOderForm(): void; //очистка формы  
    submitOder(): void; //завершение оформления  
}  

В случае ошибки  
type OderFormErrors = Partial<Record<keyof IOderForm, string>>;  
  
Интерфейс для состояния приложения:  
interface IAppState {  
    cardList: ICard[]; //перечень карточек  
    selectCard: ICard; //карточка при открытии  
    order: IOderForm; //заказ  
    basket: ICard[]; //перечень карточек в корзине  
    totalPrice: number; //сумма заказа (в postman сумма total)  
    isCardInBasket(): boolean;//метод для проверки наличия в корзине (вернуть значение, выбрана ли карточка (selected))  
    getCardInBasket(): number;//метод получить количество карточек в корзине  
    getCardIdInBasket(): number;//метод получить id карточек в корзине  
    getTotalPrice(): number;//метод отобразить сумму заказа по всем карточкам в корзине, меняется в зависимости от доб./удаления карточек  
    makeOrder(): void;//метод сдеалть заказ  
    clearBasket(): void;//метод очистить данные корзины после подтверждения оформления заказа  
}  
  
Описание одной карточки в корзине:  
type BasketItem = Pick<ICard, "id" | "title" | "price">  
  
После оформления заказа мы получаем данные с сервера для отображения на странице карточек, интерфейс  
interface ICardList {  
    cardList: ICard[]; //перечень карточек  
}  
  
### PRESENTER
Содержит следующие глобальные сущности: API, EventEmmiter  
API  
Используем для:  
- получения с сервера данныех для КАРТОЧКИ ТОВАРА, списка карточек,  
- отправления данных по заказу (объект заказа)  
При описании API указываем методы "GET" (для получения данных), "PUT" (для обновления данных), "POST" (для добавления данных), "DELETE" (для удаления данных)  
enum ApiMethods {  
    GET = 'GET',  
    PUT = 'PUT',  
    POST = 'POST',  
    DELETE = 'DELETE'  
}  
EventEmmiter будем использовать как основу для управления событиями  
  
### VIEW
Содержит следующие сущности (в интерфейсах (типах) привязка к элементам HTML):  
- Главная страница (отображается список карточек товаров и значек корзина с количеством товаров).  
- Карточка товара (категория, название, описание, цена, картинка, кнопка).  
- Модальное окно (контент, кнопка).  
- Корзина содержит 2 сущности: отображение самой корзины, включая общую сумму по товарам, и отображение позиции из перечня товаров в корзине (номер по порядку, название, цена, кнопка удалить (метод удаления)).  
- Формы для оформления заказа: 2 формы: способ оплаты, адрес, имя, телефон, базовая форма: кнопка отправки, отображение ошибок после проверки.  
- Успешное завершение заказа, содержит общую сумму заказа.  




